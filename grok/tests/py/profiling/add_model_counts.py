#!/usr/bin/env python
# ----------------------------------------------------------------------
# Numenta Platform for Intelligent Computing (NuPIC)
# Copyright (C) 2015, Numenta, Inc.  Unless you have purchased from
# Numenta, Inc. a separate commercial license for this software code, the
# following terms and conditions apply:
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero Public License version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Affero Public License for more details.
#
# You should have received a copy of the GNU Affero Public License
# along with this program.  If not, see http://www.gnu.org/licenses.
#
# http://numenta.org/licenses/
# ----------------------------------------------------------------------

"""
Joins the CSV file from profile_data_path.py with the model counts from the
CSV generated by grok_custom_metric_stress.py; outputs the new CSV to stdout.

Appends the totalModels column.
"""

import csv
import logging
from optparse import OptionParser
import sys

from grok import logging_support



gLog = logging.getLogger(__name__)




def main(profileCsvPath, modelCountsCsvPath):
  """
  :param profileCsvPath: path to CSV file from profile_data_path.py

  :param modelCountsCsvPath: path to CSV file from grok_custom_metric_stress.py
  """
  with open(profileCsvPath, "rb") as profileCsv, \
       open(modelCountsCsvPath, "rb") as modelsCsv:
    profileReader = csv.reader(profileCsv)

    modelsReader = csv.reader(modelsCsv)

    writer = csv.writer(sys.stdout)
    try:
      profileHeader = profileReader.next()
      modelsHeader = modelsReader.next()

      # Emit a combined header
      headerRow = profileHeader + ["totalModels"]
      writer.writerow(headerRow)

      # Load model counts
      modelsTimestampIndex = modelsHeader.index("timestamp")
      modelsTotalModelsIndex = modelsHeader.index("totalModels")

      modelTimestampsAndCounts = []

      for modelsRow in modelsReader:
        modelTimestampsAndCounts.insert(
          0,
          (float(modelsRow[modelsTimestampIndex]),
           int(modelsRow[modelsTotalModelsIndex])))

      # Join Profile CSV rows with model counts and output the rows
      headRowTimestampIndex = profileHeader.index("headTS")
      for row in profileReader:
        # Find matching model count
        headTS = float(row[headRowTimestampIndex])

        for timestamp, modelCount in modelTimestampsAndCounts:
          if headTS >= timestamp:
            break
        else:
          modelCount = None

        # Append model count and emit the row
        row.append(modelCount)
        writer.writerow(row)
    finally:
      sys.stdout.flush()



def _parseArgs():
  """ Parses command-line args

  :returns: a dict:
    {"profileCsvPath": <profileCsvPath>,
    "modelCountsCsvPath": <modelCountsCsvPath>}
  """
  helpString = (
    "Joins the CSV file from profile_data_path.py with the model counts from "
    "the CSV generated by grok_custom_metric_stress.py; outputs the new CSV to "
    "stdout. (appends the totalModels column)\n"
    "%prog <PROFILE_CSV_PATH> <MODEL_COUNTS_CSV_PATH>"
    )

  parser = OptionParser(helpString)

  (_options, posArgs) = parser.parse_args()

  if len(posArgs) != 2:
    parser.error("Expected two positional args, but got %s: %s" % (
                 len(posArgs), posArgs,))

  profileCsvPath, modelCountsCsvPath = posArgs

  return dict(profileCsvPath=profileCsvPath,
              modelCountsCsvPath=modelCountsCsvPath)



if __name__ == "__main__":
  logging_support.LoggingSupport.initTool()

  try:
    main(**_parseArgs())
  except Exception:
    gLog.exception("Failed")
    raise
