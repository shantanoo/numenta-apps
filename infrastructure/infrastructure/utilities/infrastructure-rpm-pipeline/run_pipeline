#!/usr/bin/env python
# ----------------------------------------------------------------------
# Numenta Platform for Intelligent Computing (NuPIC)
# Copyright (C) 2015, Numenta, Inc.  Unless you have purchased from
# Numenta, Inc. a separate commercial license for this software code, the
# following terms and conditions apply:
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero Public License version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Affero Public License for more details.
#
# You should have received a copy of the GNU Affero Public License
# along with this program.  If not, see http://www.gnu.org/licenses.
#
# http://numenta.org/licenses/
# ----------------------------------------------------------------------

"""
  Infrastructure-rpm-pipeline script

  Workflow:

  1. create rpm for salt-cellar
    a. run the script ./create-grok-saltcellar-rpm

  2. move the rpm to rpmbuild.groksolutions.com: /opt/numenta/s3Repo/s3/noarch
     with fabric api. put()

  3. create rpm for Numenta-infrastructure-pipeline
      a. run the script ./create-grok-infrastructure-rpm

  4. move the rpm to rpmbuild.groksolutions.com: /opt/numenta/s3Repo/s3/noarch
     with fabric api. put()

  5.run update-individual-repo script from rpmbuild.groksolutions.com
    (running this script uploads the infrastructure and saltcellar rpms to s3)

"""

import argparse
import errno
import glob
import os
import pkg_resources

import yaml

from fabric.api import settings, run
from fabric.operations import put

from infrastructure.utilities import exceptions
from infrastructure.utilities.cli import runWithOutput
from infrastructure.utilities.path import changeToWorkingDir
from infrastructure.utilities.diagnostics import initPipelineLogger



PRODUCTS_PATH = os.environ.get("PRODUCTS")
OPERATIONS_SCRIPTS = os.path.join(PRODUCTS_PATH, "infrastructure")

g_config = yaml.load(pkg_resources.resource_stream(__name__,
                                                   "conf/config.yaml"))
g_serverKey = os.environ["KEY_PATH"]


def removeStaleRpms(rpmNamePattern, logger):
  """
    Removes the Stale RPM

    :param rpmNamePattern: Delete pattern matching RPM Name.
                           example : grok-saltcellar-*.rpm

    :param logger: An initialized logger.

    :raises : OSError for permission denied exception.
  """
  with changeToWorkingDir(OPERATIONS_SCRIPTS):
    for rpmName in glob.glob(rpmNamePattern):
      logger.debug("Removing %s", rpmName)
      try:
        os.remove(rpmName)
      except OSError as e:
        if e.errno == errno.EACCES:
          logger.error("Permission denied for deleting %s RPM", rpmName)
          raise
        else:
          logger.exception("Error number %s occurred with OSError", e.errno)

def executeScript(rpmNameBase, script, logger):
  """
    Runs the script to create the RPM.

    :param rpmNameBase: Base name of the RPM to be created
                        example: grok-saltcellar

    :param script: script to be executed, which is basically a bash script
                   which creates RPM
    :param logger: An initialized logger.

    :returns: Name of the RPM generated by executing script.
    :rtype: Srting

    :raises: infrastructure.utilities.exceptions.MissingRPMError if there
             is no RPM created.
             infrastructure.utilities.exceptions.MultipleRPMForSamePackageError
             if more than one RPM with same rpmNamePattern exist.
  """
  rpmPath = os.path.join(PRODUCTS_PATH, "infrastructure")
  rpmNamePattern = rpmNameBase + "-*.rpm"

  with changeToWorkingDir(rpmPath):
    logger.info(" ++++++++++++ Creating %s RPM ++++++++++++ ", rpmNameBase)
    # Calling specific bash script to create RPM
    runWithOutput(script, logger=logger)
    nameOfRpmCreated = glob.glob(rpmNamePattern)

    if not nameOfRpmCreated:
      raise exceptions.MissingRPMError("Failed to create %s RPM" % rpmNameBase)
    if len(nameOfRpmCreated) != 1:
      raise exceptions.MultipleRPMForSamePackageError("Error occurred because "
                                                      "more than one RPM found "
                                                      "with %s pattern" %
                                                      rpmNamePattern)
    else:
      return nameOfRpmCreated[0]


def moveRpmToRpmbuild(rpmName, config, logger):
  """
    Copies an RPM from slave to rpmbuild.groksolutions.com

    :param rpmName: The RPM which is to be moved
    :param config: This is a dict of configuration data.
    :param logger: An initialized logger.

    :raises: infrastructure.utilities.exceptions.FailedToMoveRPM
             when it fails to move RPM.
  """
  logger.info("++++++++++++ Moving %s ++++++++++++", rpmName)
  with settings(host_string=os.environ["RPMBUILDBOX"],
                key_filename=g_serverKey,
                user=config["USER"], connection_attempts=10):
    localPath = os.path.join(OPERATIONS_SCRIPTS, rpmName)
    status = put(localPath.rstrip(), config["NOARCH_REPO_PATH"])
    if not status.succeeded:
      raise exceptions.FailedToMoveRPM("Failed to move %s to rpmbuild." %
                                       rpmName)


def syncRepoWithS3(repoName, logger):
  """
    This is wrapper which in turn invokes functions for syncing /uploading rpms
    on S3 and updating pipeline json if provided

    :param repoName: The directory for where to run the command
    :param logger: An initialized logger.

    :raises : infrastructure.utilities.exceptions.RPMSyncError
              if it fails to sync repo
  """

  with settings(host_string=os.environ["RPMBUILDBOX"],
                key_filename=g_serverKey, user=g_config["USER"],
                connection_attempts=10, warn_only=True):
    logger.info("+++++++++++++ Synchronizing repository with S3 +++++++++++++")
    result = run("update-individual-repo %s" % repoName)
    if result.return_code:
      raise exceptions.RPMSyncError("Failed to sync repo %s" % repoName)


def parseArgs():
  """
    Parse the command line arguments

    :returns: The Parsed arguments from the command line
    :rtype: argparse.Namespace
  """
  parser = argparse.ArgumentParser(description=("Build the "
                                                "Infrastructure-rpm-pipeline "
                                                "and grok-saltcellar-rpm "))

  parser.add_argument("--log", dest="logLevel", type=str, default="info",
                      help="Logging level, optional parameter and defaulted to"
                           " level info")

  return parser.parse_args()


def main(args):
  """
    Main function for the pipeline. Executes all sub-tasks.

    :param args: Parsed command line arguments
  """
  logger = initPipelineLogger("Infrastructure-rpm-pipeline",
                              logLevel=args.logLevel)

  removeStaleRpms("grok-saltcellar-*.rpm", logger)
  rpmName = executeScript("grok-saltcellar", "./create-grok-saltcellar-rpm",
                          logger)
  moveRpmToRpmbuild(rpmName, g_config, logger)

  removeStaleRpms("numenta-infrastructure-python-*.rpm", logger)
  rpmName = executeScript("numenta-infrastructure-python",
                          "./create-infrastructure-python-rpm", logger)
  moveRpmToRpmbuild(rpmName, g_config, logger)
  syncRepoWithS3("noarch", logger)


if __name__ == "__main__":
  main(parseArgs())
