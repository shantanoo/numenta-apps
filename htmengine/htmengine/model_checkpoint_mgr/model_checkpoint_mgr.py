# ----------------------------------------------------------------------
# Numenta Platform for Intelligent Computing (NuPIC)
# Copyright (C) 2015, Numenta, Inc.  Unless you have purchased from
# Numenta, Inc. a separate commercial license for this software code, the
# following terms and conditions apply:
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero Public License version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Affero Public License for more details.
#
# You should have received a copy of the GNU Affero Public License
# along with this program.  If not, see http://www.gnu.org/licenses.
#
# http://numenta.org/licenses/
# ----------------------------------------------------------------------

"""
This module implements the Model Checkpoint Manager that's responsible for
saving and loading models to persistent storage.
"""

import errno
import json
import os
import shutil
import tempfile
import time

from nupic.frameworks.opf.modelfactory import ModelFactory

from htmengine import htmengine_logging

from nta.utils import makeDirectoryFromAbsolutePath
from nta.utils.config import Config



_MODULE_NAME = "htmengine.model_checkpoint_mgr"



class ModelCheckpointConfig(Config):
  """ Model Checkpoint layer's configuration parser.
  """


  CONFIG_NAME = "model-checkpoint.conf"


  def __init__(self):
    super(ModelCheckpointConfig, self).__init__(
      self.CONFIG_NAME,
      os.environ.get("APPLICATION_CONFIG_PATH"))



class ModelNotFound(Exception):
  """ Raised from load() or loadMetaInfo() if the given modelID is not found
    in storage.
  """
  pass



class ModelAlreadyExists(Exception):
  """ The model already exists """
  pass



def _getLogger():
  return htmengine_logging.getExtendedLogger(_MODULE_NAME)



class ModelCheckpointMgr(object):
  """
  Goal: saving of model definitions, checkpoints and attributes must be atomic -
    either everything succeeds and the new checkpoint becomes available or
    something fails (possibly even the kernel) and the old checkpoint's
    integrity is preserved. There is no provision for disk corruption, however.

  ModelCheckpointMgr internals documentation:

  Model Checkpoint archive layout: the top level directory names are the model
  IDs (e.g., 1ebd2d27dfd74cd98f96220721b9a257). The following example
  demonstrates the layout of a model entry in this archive:

  1ebd2d27dfd74cd98f96220721b9a257
    definition.data
    version.txt
    current_checkpoint --> (a link to checkpoint_store_<timestamp> dir)

    checkpoint_store_1389761327.552464/ (seconds since epoch as suffix)
      attributes.data
      model_instance/ (the contents are generated by CLA model)
        model.pkl
        modelextradata/
          TemporalAnomaly-network.nta/
            R0-pkl
            . . .
  """


  # Current model entry version
  _MODEL_ENTRY_VERSION = "2.0"

  # Root-level directory for creating temporary directories or files; located in
  # the root storage directory; NOTE: this location in the same filesystem as
  # the actual model checkpoint stores enables the temporary directory or file
  # to be "moved" efficiently simply by renaming its path
  _SCRATCH_DIR_NAME = ".scratch"

  # The filename that contains the model archive version; located at top level
  # of each model's archive
  _MODEL_ENTRY_VERSION_FILE_NAME = "version.txt"

  # JSON filename containing the model definition; located at top level of
  # each model's archive
  _MODEL_DEFINITION_FILE_NAME = "definition.data"

  # Link to the actual current model checkpoint store directory; located at
  # top level of each model's archive
  _CHECKPOINT_LINK_NAME = "current_checkpoint"

  # Directory name base of the actual model checkpoint store; the directory
  # name is composed by appending the current unix timestamp (with fraction);
  # located at top level of each model's archive
  _CHECKPOINT_STORE_DIR_NAME_BASE = "checkpoint_store_"

  # The model checkpoint attributes JSON object is stored in this file in the
  # model checkpoint store directory
  _CHECKPOINT_ATTRIBUTES_FILE_NAME = "attributes.data"

  # Name of directory that contains the pickled model instance; located in the
  # actual model checkpoint store directory
  _CHECKPOINT_INSTANCE_DIR_NAME = "model_instance"


  def __init__(self):
    self._logger = _getLogger()

    # Get the directory in which to save/load checkpoints
    self._storageRoot = self._getStorageRoot()

    self._logger.debug("Using storage root=%s", self._storageRoot)

    if not os.path.exists(self._storageRoot):
      makeDirectoryFromAbsolutePath(self._storageRoot)

    self._scratchDir = os.path.join(self._storageRoot, self._SCRATCH_DIR_NAME)
    if not os.path.exists(self._scratchDir):
      makeDirectoryFromAbsolutePath(self._scratchDir)


  @classmethod
  def _getStorageRoot(cls):
    storageRoot = ModelCheckpointConfig().get("storage", "root")
    storageRoot = os.path.expanduser(os.path.expandvars(storageRoot))

    if not os.path.isabs(storageRoot):
      raise ValueError("Model Checkpoint root path is not absolute: %r" %
                       (storageRoot,))

    return os.path.realpath(storageRoot)


  def _getModelDir(self, modelID, mustExist):
    """ Get the directory path of the model entry

    param modelID: model ID of the model
    param mustExist: If true, and the directory does not exist, raise a
      ModelNotFound exception
    """

    modelRootPath = os.path.join(self._storageRoot, modelID)
    if mustExist and not os.path.exists(modelRootPath):
      raise ModelNotFound("Model archive not found for model=%s" % (modelID,))

    return modelRootPath


  def _getCurrentCheckpointRealPath(self, modelID):
    """ Get the real path of the model's existing checkpoint store directory,
    resolving all links

    raises:
      ModelNotFound if the model checkpoint hasn't been saved yet or if this
        model's entry doesn't exist in the checkpoint archive
    """
    currentStoreSymlinkPath = os.path.join(
      self._getModelDir(modelID, mustExist=True),
      self._CHECKPOINT_LINK_NAME)

    # Follow the chekpoint link
    checkpointStoreDirPath = os.path.realpath(currentStoreSymlinkPath)

    if not os.path.exists(checkpointStoreDirPath):
      raise ModelNotFound("Checkpoint not found for model=%s; expected "
                          "directory=%s" % (modelID, checkpointStoreDirPath,))

    assert checkpointStoreDirPath != currentStoreSymlinkPath, (
      checkpointStoreDirPath)

    return checkpointStoreDirPath


  @classmethod
  def _fsyncReliably(cls, fd):
    """ perform fsync operation on the given file descriptor, retrying on EINTR
    param fd: file descriptor for the fsync operation
    """
    while True:
      try:
        os.fsync(fd)
        break
      except OSError as e:
        if e.errno == errno.EINTR:
          # Interrupted by signal, so need to retry fsync
          continue
        else:
          raise

  @classmethod
  def _fsyncDirectoryOnly(cls, dirPath):
    assert os.path.isdir(dirPath), dirPath

    dirfd = os.open(dirPath, os.O_DIRECTORY)
    try:
      cls._fsyncReliably(dirfd)
    finally:
      os.close(dirfd)


  @classmethod
  def _fsyncFile(cls, filePath):
    # Can't sync a symlink
    if os.path.islink(filePath):
      return

    fd = os.open(filePath, os.O_RDONLY)
    try:
      cls._fsyncReliably(fd)
    finally:
      os.close(fd)


  def _fsyncDirectoryTreeRecursively(self, rootPath):
    """ Perfrom bottom-up file and directory fsync, including the specified
    rootPath

    param rootPath: the path of the root directory of the tree to fsync
    """
    assert os.path.isdir(rootPath), rootPath

    # Perform bottom-up fsync of the contents
    for (parentPath, dirNames, fileNames) in os.walk(
        rootPath, topdown=False, onerror=None, followlinks=False):
      for f in fileNames:
        self._fsyncFile(os.path.join(parentPath, f))
      for d in dirNames:
        self._fsyncDirectoryOnly(os.path.join(parentPath, d))

    # fsync rootPath directory last
    self._fsyncDirectoryOnly(rootPath)


  def define(self, modelID, definition):
    """ Define a new model in model checkpoint archive.

    :param modelID: unique model ID hex string
    :param definition: jsonifiable python object containing model definition
      parameters.

    raises:
      ModelAlreadyExists if an entry already exists for the given modelID in the
        checkpoint archive

    """
    startTime = time.time()

    modelEntryDirPath = self._getModelDir(modelID, mustExist=False)
    if os.path.exists(modelEntryDirPath):
      raise ModelAlreadyExists(
        "Model archive entry already exists for model=%s at path=%s" %
        (modelID, modelEntryDirPath,))

    # Create the model entry subtree in a temp directory first, then rename it
    # to its permanent location in the model archive for integrity

    tempRoot = tempfile.mkdtemp(prefix=modelID, dir=self._scratchDir)

    try:
      tempModelEntryDirPath = os.path.join(tempRoot, modelID)
      makeDirectoryFromAbsolutePath(tempModelEntryDirPath)

      # Create the model entry version file
      verFilePath = os.path.join(tempModelEntryDirPath,
                                 self._MODEL_ENTRY_VERSION_FILE_NAME)
      with open(verFilePath, "wb") as fileObj:
        fileObj.write(self._MODEL_ENTRY_VERSION)

      # Create the model definition file
      definitionFilePath = os.path.join(tempModelEntryDirPath,
                                        self._MODEL_DEFINITION_FILE_NAME)
      with open(definitionFilePath, "wb") as fileObj:
        json.dump(definition, fileObj)

      # Get temp model entry tree in consistent state
      self._fsyncDirectoryTreeRecursively(tempModelEntryDirPath)

      # Atomically rename the temp model entry dir as the actual model entry dir
      os.rename(tempModelEntryDirPath, modelEntryDirPath)

      # Get checkpoint storage root directory into consistent state
      self._fsyncDirectoryOnly(self._storageRoot)
    finally:
      # Clean up
      shutil.rmtree(tempRoot)


    self._logger.info(
      "{TAG:MCKPT.DEFINE} "
      "Created entry for model=%s: duration=%ss; directory=%s",
      modelID, time.time() - startTime, modelEntryDirPath)


  def loadModelDefinition(self, modelID):
    """ Load definition of the model

    param modelID: unique model ID hex string

    retval: python object value that was passed to the define() method as the
      model's definition

    raises:
      ModelNotFound if model's entry doesn't exit in the checkpoint archive
    """
    modelEntryDirPath = self._getModelDir(modelID, mustExist=True)
    definitionFilePath = os.path.join(modelEntryDirPath,
                                      self._MODEL_DEFINITION_FILE_NAME)
    with open(definitionFilePath) as fileObj:
      return json.load(fileObj)


  def save(self, modelID, model, attributes):
    """ Checkpoint a model instance.

    :param modelID: unique model ID hex string

    :param model: An OPF model instance object. This represents an instantiated
      model that may have processed records and accumulated learning state.

    :param attributes: checkpoint attributes; a JSONifiable object to save as an
      integral component of the checkpoint. It may later be retrieved separately
      via ModelCheckpointMgr.loadCheckpointAttributes()

    :raises: ModelNotFound if model's entry doesn't exit in the checkpoint
      archive
    """
    startTime = time.time()

    modelEntryDirPath = self._getModelDir(modelID, mustExist=True)

    # Create the model checkpoint store in a temp directory first, then rename
    # it to its location in the model entry for integrity

    tempRoot = tempfile.mkdtemp(prefix=modelID, dir=self._scratchDir)
    try:
      tempCheckpointStoreDirPath = os.path.join(
        tempRoot,
        self._CHECKPOINT_STORE_DIR_NAME_BASE)
      makeDirectoryFromAbsolutePath(tempCheckpointStoreDirPath)

      # Save the checkpoint attributes
      attributesFilePath = os.path.join(
        tempCheckpointStoreDirPath,
        self._CHECKPOINT_ATTRIBUTES_FILE_NAME)

      with open(attributesFilePath, "wb") as fileObj:
        json.dump(attributes, fileObj)

      # Save the model
      model.save(
        saveModelDir=os.path.join(
          tempCheckpointStoreDirPath,
          self._CHECKPOINT_INSTANCE_DIR_NAME))

      # Get temp checkpoint store tree in consistent state
      self._fsyncDirectoryTreeRecursively(tempCheckpointStoreDirPath)

      # Atomically rename the temp checkpoint store dir into model entry dir
      newCheckpointStoreDirPath = os.path.join(
        modelEntryDirPath,
        "%s%f" % (self._CHECKPOINT_STORE_DIR_NAME_BASE, time.time()))

      assert not os.path.exists(newCheckpointStoreDirPath), (
        newCheckpointStoreDirPath)

      os.rename(tempCheckpointStoreDirPath, newCheckpointStoreDirPath)

      # Prepare to switch the current checkpoint link
      currentStoreSymlinkPath = os.path.join(
        modelEntryDirPath,
        self._CHECKPOINT_LINK_NAME)

      # But first, capture the real path of the old checkpoint store, so we can
      # delete it later
      if os.path.exists(currentStoreSymlinkPath):
        oldCheckpointStoreDirPath = os.path.realpath(currentStoreSymlinkPath)
        assert oldCheckpointStoreDirPath != currentStoreSymlinkPath, (
          oldCheckpointStoreDirPath)
      else:
        oldCheckpointStoreDirPath = None

      # Atomically point currentStoreSymlinkPath to
      #  newCheckpointStoreDirPath
      tempCurrentStoreSymlinkPath = os.path.join(
        tempRoot,
        self._CHECKPOINT_LINK_NAME)
      os.symlink(newCheckpointStoreDirPath, tempCurrentStoreSymlinkPath)
      os.rename(tempCurrentStoreSymlinkPath, currentStoreSymlinkPath)

      # Sync the model entry directory to ensure consistency
      # NOTE: we do this before deleting the old checkpoint store to protect
      # current checkpoint integrity in the event of failure while deleting the
      # old one.
      self._fsyncDirectoryOnly(modelEntryDirPath)

      # Lastly, remove the old checkpoint store dir
      if oldCheckpointStoreDirPath is not None:
        shutil.rmtree(oldCheckpointStoreDirPath)
    finally:
      # Clean up
      shutil.rmtree(tempRoot)

    self._logger.info(
      "{TAG:MCKPT.SAVE} Saved model=%s: duration=%ss; directory=%s",
      modelID, time.time() - startTime, newCheckpointStoreDirPath)


  def load(self, modelID):
    """ Retrieve a model instance from checkpoint.

    param modelID: unique model ID

    retval: an OPF model instance

    raises:
      ModelNotFound if the model checkpoint hasn't been saved yet or if this
        model's entry doesn't exist in the checkpoint archive
    """
    startTime = time.time()

    checkpointStoreDirPath = self._getCurrentCheckpointRealPath(modelID)

    modelInstanceDirPath = os.path.join(checkpointStoreDirPath,
                                        self._CHECKPOINT_INSTANCE_DIR_NAME)

    model = ModelFactory.loadFromCheckpoint(modelInstanceDirPath)

    self._logger.info(
      "{TAG:MCKPT.LOAD} Loaded model=%s: duration=%ss; directory=%s",
      modelID, time.time() - startTime, checkpointStoreDirPath)

    return model


  def updateCheckpointAttributes(self, modelID, attributes):
    """ Update model checkpoint attributes

    :param modelID: unique model ID hex string

    :param attributes: checkpoint attributes; a JSONifiable object to save as an
      integral component of the checkpoint. It may later be retrieved separately
      via ModelCheckpointMgr.loadCheckpointAttributes()

    :raises: ModelNotFound if the model checkpoint hasn't been saved yet or if
      this model's entry doesn't exist in the checkpoint archive
    """
    checkpointDirPath = self._getCurrentCheckpointRealPath(modelID)

    attributesFilePath = os.path.join(checkpointDirPath,
                                      self._CHECKPOINT_ATTRIBUTES_FILE_NAME)

    # Create the new attributes file as a temp in our scratch directory
    (tempFd, tempPath) = tempfile.mkstemp(
      suffix=self._CHECKPOINT_ATTRIBUTES_FILE_NAME,
      prefix=modelID,
      dir=self._scratchDir,
      text=False)

    with os.fdopen(tempFd, "wb") as fileObj:
      json.dump(attributes, fileObj)
      # Get the temp file in consitent state
      fileObj.flush()
      self._fsyncReliably(tempFd)

    # Automically move the temp file into the current checkpoint
    os.rename(tempPath, attributesFilePath)

    # Get checkpoint directory into consistent state
    self._fsyncDirectoryOnly(checkpointDirPath)


  def loadCheckpointAttributes(self, modelID):
    """ Retrieve the model checkpoint attributes that are saved as an integral
    component of the model checkpoint (versus model definition that is saved
    separately from the checkpoint).

    :param modelID: unique model ID

    :returns: model checkpoint attributes python object that was saved by
      ModelCheckpointMgr.save() or
      ModelCheckpointMgr.updateCheckpointAttributes()

    :raises: ModelNotFound if the model checkpoint hasn't been saved yet or if
      this model's entry doesn't exist in the checkpoint archive
    """
    attributesFilePath = os.path.join(
      self._getCurrentCheckpointRealPath(modelID),
      self._CHECKPOINT_ATTRIBUTES_FILE_NAME)

    with open(attributesFilePath) as fileObj:
      return json.load(fileObj)


  def clone(self, modelID, destModelID):
    """ Clone an existing model archive

    :param modelID: unique model ID hex string of the source model
    :param destModelID: unique model ID hex string of the destination model

    :raises:
      ModelNotFound if the source model doesn't exist
      ModelAlreadyExists if the destination model already exists
    """
    startTime = time.time()

    srcModelEntryDirPath = self._getModelDir(modelID, mustExist=True)

    destModelEntryDirPath = self._getModelDir(destModelID, mustExist=False)
    if os.path.exists(destModelEntryDirPath):
      raise ModelAlreadyExists(
        "Model archive entry already exists for clone destModel=%s at "
        "path=%s" % (destModelID, destModelEntryDirPath,))

    # Create the model entry tree in a temp directory first, then rename it
    # to its permanent location in the model archive for integrity

    tempRoot = tempfile.mkdtemp(prefix=destModelID, dir=self._scratchDir)
    try:
      # Copy the source model entry to destination entry in temp tree
      tempModelEntryDirPath = os.path.join(tempRoot, destModelID)
      shutil.copytree(srcModelEntryDirPath,
                      tempModelEntryDirPath,
                      symlinks=True)

      # Fix up the checkpoint store link, if present
      tempStoreSymlinkPath = os.path.join(tempModelEntryDirPath,
                                          self._CHECKPOINT_LINK_NAME)
      if os.path.exists(tempStoreSymlinkPath):
        srcCheckpointStoreDirPath = os.path.realpath(tempStoreSymlinkPath)
        os.unlink(tempStoreSymlinkPath)
        os.symlink(
          os.path.join(destModelEntryDirPath,
                       os.path.basename(srcCheckpointStoreDirPath)),
          tempStoreSymlinkPath)

      # Get temp model entry tree in consistent state
      self._fsyncDirectoryTreeRecursively(tempModelEntryDirPath)

      # Atomically relocate the temp model entry tree to the model archive
      os.rename(tempModelEntryDirPath, destModelEntryDirPath)

      # Get checkpoint storage root directory into consistent state
      self._fsyncDirectoryOnly(self._storageRoot)
    finally:
      # Clean up
      shutil.rmtree(tempRoot)

    self._logger.info(
      "{TAG:MCKPT.CLONE} "
      "Cloned srcModel=%s to destModel=%s: duration=%ss; directory=%s",
      modelID, destModelID, time.time() - startTime, destModelEntryDirPath)


  def remove(self, modelID):
    """ Remove the model entry with the given model ID from storage

    :param modelID: model ID to remove

    :raises: ModelNotFound if model's entry doesn't exit in the checkpoint
      archive
    """
    tempRoot = tempfile.mkdtemp(prefix=modelID, dir=self._scratchDir)
    try:
      # Move model entry atomically to scratch dir
      modelEntryDirPath = self._getModelDir(modelID, mustExist=True)
      os.rename(modelEntryDirPath, os.path.join(tempRoot, "deleteMe"))
      self._fsyncDirectoryOnly(self._storageRoot)
    finally:
      # Then, delete from scratch dir
      shutil.rmtree(tempRoot)


  @classmethod
  def removeAll(cls):
    """ Remove all checkpoints
    """
    storageRoot = cls._getStorageRoot()

    if os.path.exists(storageRoot) and os.path.isdir(storageRoot):
      _getLogger().info("removeAll: Removing all model checkpoints at dir=%s",
                        storageRoot)
      shutil.rmtree(storageRoot)
    else:
      _getLogger().info("removeAll: not a directory or doesn't exist: %s",
                        storageRoot)


  def getModelIDs(self):
    """ Return a sequence of all model IDs found in storage

    :returns: sequence of model IDs
    """
    try:
      dirNames = os.listdir(self._storageRoot)
    except OSError as e:
      if e.errno == errno.ENOENT:
        return list()
      else:
        raise
    return [x for x in dirNames if not x.startswith('.')]
