#!/usr/bin/env python
# ----------------------------------------------------------------------
# Numenta Platform for Intelligent Computing (NuPIC)
# Copyright (C) 2015, Numenta, Inc.  Unless you have purchased from
# Numenta, Inc. a separate commercial license for this software code, the
# following terms and conditions apply:
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero Public License version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Affero Public License for more details.
#
# You should have received a copy of the GNU Affero Public License
# along with this program.  If not, see http://www.gnu.org/licenses.
#
# http://numenta.org/licenses/
# ----------------------------------------------------------------------

"""
Override opmode of collectors in collectors configuration
"""

import logging
from optparse import OptionParser

from taurus import metric_collectors
from taurus.metric_collectors import ApplicationConfig
from taurus.metric_collectors import logging_support



g_log = logging.getLogger("set_collectors_opmode")



def _parseArgs():
  """ Display help, if requested, and validate that no unexpected args are
  passed
  :returns: dict with the following properties:
      opmode - opmode value; one of ApplicationConfig.OP_MODE_*
  """

  helpString = (
    "%%prog OPMODE\n\n"
    "Override opmode of all collector agents in collectors configuration.\n"
    "OPMODE may be one of:\n"
    "    %12s - collect and forward data to Taurus\n"
    "    %12s - collect (and store), but don't forward data" %
    (ApplicationConfig.OP_MODE_ACTIVE, ApplicationConfig.OP_MODE_HOT_STANDBY))

  parser = OptionParser(helpString)


  _options, positionalArgs = parser.parse_args()
  if not positionalArgs:
    parser.error("Expected one positional arg for OPMODE, but got none")
  if len(positionalArgs) != 1:
    parser.error("Expected exactly one positional arg, but got %d: %r" %
                 (len(positionalArgs), positionalArgs,))

  opmode = positionalArgs[0]
  if opmode not in ApplicationConfig.ALL_OP_MODES:
    parser.error("Unexpected OPMODE; got %r, but must be one of %r" %
                 (opmode, ApplicationConfig.ALL_OP_MODES))

  return dict(
    opmode=opmode
  )


def main():
  """
  NOTE: main also serves as entry point for "console script" generated by setup
  """
  logging_support.LoggingSupport.initTool()

  args = _parseArgs()

  opmode = args["opmode"]

  configWriter = ApplicationConfig(mode=ApplicationConfig.MODE_OVERRIDE_ONLY)
  updatedSections = dict()
  for section in metric_collectors.config.sections():
    if metric_collectors.config.has_option(section, "opmode"):
      if not configWriter.has_section(section):
        configWriter.add_section(section)

      configWriter.set(section, "opmode", opmode)

      oldOpmode = metric_collectors.config.get(section, "opmode")
      newOpmode = configWriter.get(section, "opmode")
      assert newOpmode == opmode, (newOpmode, opmode)
      updatedSections[section] = "%s -> %s" % (oldOpmode, newOpmode)

  configWriter.save()

  g_log.info("Updated config sections=%s", updatedSections)


if __name__ == "__main__":
  main()
